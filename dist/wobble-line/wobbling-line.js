class WobblingLine extends HTMLElement{self=WobblingLine;static ATTR_TICK='tick';static ON_PHASE='onphase';static TAG="wobbling-line";$canvas;context;timerHandler;prevTick;segments;listeners;tickSize;constructor(...args){super(...args);this.prevTick=0;this.timerHandler=undefined;this.$canvas=undefined;this.context=undefined;this.segments=[];this.tickSize=30;this.listeners={};this.listeners[this.self.ON_PHASE]=[];const tpl=`<canvas></canvas><slot></slot>`;this.style.display='block';this.attachShadow({mode:"open"});this.shadowRoot.innerHTML=tpl;this.$canvas=this.shadowRoot.querySelector('canvas');this.context=this.$canvas.getContext('2d');this.$canvas.style.width='100%';this.$canvas.style.height='100%'}connectedCallback(){this.detectSegments();this.tickSize=parseInt(this.getAttribute(this.self.ATTR_TICK)??this.tickSize);this.prevTick=0;this.timerHandler=setInterval(this.ontick,this.tickSize,this);console.debug("wobbling tick",this.tickSize);const funcname=this.getAttribute(this.self.ON_PHASE);if(funcname){const func=window[funcname];this.addEventListener(this.self.ON_PHASE,func)}}disconnectedCallback(){clearInterval(this.timerHandler);this.timerHandler=undefined;this.listeners={}}addEventListener(event_name,func){this.listeners[event_name].push(func)}tick(prevTick,curTick){this.context.clearRect(0,0,this.$canvas.width,this.$canvas.height);for(const segment of this.segments)segment.draw(prevTick,curTick)}ontick(self){const curTick=self.prevTick+self.tickSize;self.tick(self.prevTick,curTick);self.prevTick=curTick}detectSegments(){this.segments=Array.from(this.querySelectorAll(WobblingSegment.TAG));this.segments.forEach((segment)=>{segment.setHost(this)})}}class WobblingSegment extends HTMLElement{static TAG='wobbling-segment';static masterID=1;sid;p;l;a;f;d;host=undefined;context;hostStyle;constructor(...args){super(...args);this.sid=WobblingSegment.masterID++;this.p=parseFloat(this.getAttribute('p')||0.5);this.l=parseFloat(this.getAttribute('l')||0.5);this.a=parseFloat(this.getAttribute('a')||0.5);this.f=parseFloat(this.getAttribute('f')||1.0);this.d=parseFloat(this.getAttribute('d')||0.0);this.host=undefined;this.context=undefined;this.hostStyle=undefined}setHost(host){this.host=host;this.context=this.host.$canvas.getContext('2d');this.hostStyle=window.getComputedStyle(this.host)}draw(prevTick,curTick){const T_ms=(1/this.f)*1000;const time=curTick-this.d;const angle=((time%T_ms)*360)/T_ms;const amplitude_factor=this.a*Math.sin(this.deg2rad(angle));const amplitude=100-((amplitude_factor*100)+50);const y=50;const peak=100*this.p;const half=(100*this.l)/2;const abs_amplitude=(amplitude/100)*this.host.$canvas.height;const abs_y=(y/100)*this.host.$canvas.height;const abs_peak=(peak/100)*this.host.$canvas.width;const abs_half=(half/100)*this.host.$canvas.width;this.context.beginPath();this.context.strokeStyle=window.getComputedStyle(this).stroke;this.context.moveTo(abs_peak-abs_half,abs_y);this.context.quadraticCurveTo(abs_peak,abs_amplitude,abs_peak+abs_half,abs_y);this.context.stroke();const prev_time=prevTick-this.d;const prev_angle=((prev_time%T_ms)*360)/T_ms;for(const listener of this.host.listeners[this.host.self.ON_PHASE])listener.call(listener,this,prev_angle,angle)}deg2rad(angle){return(angle*Math.PI)/180.0}}customElements.define(WobblingSegment.TAG,WobblingSegment);customElements.define(WobblingLine.TAG,WobblingLine);